This file is part of MXE.
See index.html for further information.

diff -urN hdf5-1.8.10.orig/src/H5Tinit.c hdf5-1.8.10/src/H5Tinit.c
--- hdf5-1.8.10.orig/src/H5Tinit.c	1970-01-01 10:00:00.000000000 +1000
+++ hdf5-1.8.10/src/H5Tinit.c	2012-12-05 22:18:00.000000000 +1100
@@ -0,0 +1,978 @@
+/* Generated automatically by H5detect -- do not edit */

+

+

+

+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

+ * Copyright by The HDF Group.                                               *

+ * Copyright by the Board of Trustees of the University of Illinois.         *

+ * All rights reserved.                                                      *

+ *                                                                           *

+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *

+ * terms governing use, modification, and redistribution, is contained in    *

+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *

+ * of the source code distribution tree; Copyright.html can be found at the  *

+ * root level of an installed copy of the electronic HDF5 document set and   *

+ * is linked from the top-level documents page.  It can also be found at     *

+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *

+ * access to either file, you may request a copy from help@hdfgroup.org.     *

+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

+ *

+ * Created:		Dec  5, 2012

+ *

+ *

+ * Purpose:		This machine-generated source code contains

+ *			information about the various integer and

+ *			floating point numeric formats found on this

+ *			architecture.  The parameters below should be

+ *			checked carefully and errors reported to the

+ *			HDF5 maintainer.

+ *

+ *			Each of the numeric formats listed below are

+ *			printed from most significant bit to least

+ *			significant bit even though the actual bytes

+ *			might be stored in a different order in

+ *			memory.	 The integers above each binary byte

+ *			indicate the relative order of the bytes in

+ *			memory; little-endian machines have

+ *			decreasing numbers while big-endian machines

+ *			have increasing numbers.

+ *

+ *			The fields of the numbers are printed as

+ *			letters with `S' for the mantissa sign bit,

+ *			`M' for the mantissa magnitude, and `E' for

+ *			the exponent.  The exponent has an associated

+ *			bias which can be subtracted to find the

+ *			true exponent.	The radix point is assumed

+ *			to be before the first `M' bit.	 Any bit

+ *			of a floating-point value not falling into one

+ *			of these categories is printed as a question

+ *			mark.  Bits of integer types are printed as

+ *			`I' for 2's complement and `U' for magnitude.

+ *

+ *			If the most significant bit of the normalized

+ *			mantissa (always a `1' except for `0.0') is

+ *			not stored then an `implicit=yes' appears

+ *			under the field description.  In thie case,

+ *			the radix point is still assumed to be

+ *			before the first `M' but after the implicit

+ *			bit.

+ *

+ * Modifications:

+ *

+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!

+ *	It was generated by code in `H5detect.c'.

+ *

+ *-------------------------------------------------------------------------

+ */

+

+/****************/

+/* Module Setup */

+/****************/

+

+#define H5T_PACKAGE /*suppress error about including H5Tpkg.h*/

+

+

+/***********/

+/* Headers */

+/***********/

+#include "H5private.h"		/* Generic Functions			*/

+#include "H5Eprivate.h"		/* Error handling		  	*/

+#include "H5FLprivate.h"	/* Free Lists				*/

+#include "H5Iprivate.h"		/* IDs			  		*/

+#include "H5Tpkg.h"		/* Datatypes 				*/

+

+

+/****************/

+/* Local Macros */

+/****************/

+

+

+/******************/

+/* Local Typedefs */

+/******************/

+

+

+/********************/

+/* Package Typedefs */

+/********************/

+

+

+/********************/

+/* Local Prototypes */

+/********************/

+

+

+/********************/

+/* Public Variables */

+/********************/

+

+

+/*****************************/

+/* Library Private Variables */

+/*****************************/

+

+

+/*********************/

+/* Package Variables */

+/*********************/

+

+

+

+/*******************/

+/* Local Variables */

+/*******************/

+

+

+

+/*-------------------------------------------------------------------------

+ * Function:	H5TN_init_interface

+ *

+ * Purpose:	Initialize pre-defined native datatypes from code generated

+ *              during the library configuration by H5detect.

+ *

+ * Return:	Success:	non-negative

+ *		Failure:	negative

+ *

+ * Programmer:	Robb Matzke

+ *              Wednesday, December 16, 1998

+ *

+ *-------------------------------------------------------------------------

+ */

+herr_t

+H5TN_init_interface(void)

+{

+    H5T_t	*dt = NULL;

+    herr_t	ret_value = SUCCEED;

+

+    FUNC_ENTER_NOAPI(FAIL)

+

+   /*

+    *    0

+    * IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_SCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_SCHAR_ALIGN_g = 1;

+    H5T_NATIVE_SCHAR_COMP_ALIGN_g = 1;

+

+   /*

+    *    0

+    * UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UCHAR_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_SHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_SHORT_ALIGN_g = 1;

+    H5T_NATIVE_SHORT_COMP_ALIGN_g = 2;

+

+   /*

+    *    1        0

+    * UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_USHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_USHORT_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_ALIGN_g = 1;

+    H5T_NATIVE_INT_COMP_ALIGN_g = 4;

+

+   /*

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_LONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_LONG_ALIGN_g = 1;

+    H5T_NATIVE_LONG_COMP_ALIGN_g = 4;

+

+   /*

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_ULONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_ULONG_ALIGN_g = 1;

+

+   /*

+    *    0

+    * IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT8_ALIGN_g = 1;

+

+   /*

+    *    0

+    * UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT8_ALIGN_g = 1;

+

+   /*

+    *    0

+    * IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_LEAST8_ALIGN_g = 1;

+

+   /*

+    *    0

+    * UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_LEAST8_ALIGN_g = 1;

+

+   /*

+    *    0

+    * IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_FAST8_ALIGN_g = 1;

+

+   /*

+    *    0

+    * UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 1;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 8;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_FAST8_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT16_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT16_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_LEAST16_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_LEAST16_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_FAST16_ALIGN_g = 1;

+

+   /*

+    *    1        0

+    * UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 2;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 16;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_FAST16_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT32_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT32_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_LEAST32_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_LEAST32_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_FAST32_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_FAST32_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_LEAST64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_LEAST64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_INT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_INT_FAST64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_UINT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_UINT_FAST64_ALIGN_g = 1;

+

+   /*

+    *    7        6        5        4

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    *    3        2        1        0

+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;

+    if((H5T_NATIVE_LLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_LLONG_ALIGN_g = 1;

+    H5T_NATIVE_LLONG_COMP_ALIGN_g = 8;

+

+   /*

+    *    7        6        5        4

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    *    3        2        1        0

+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_INTEGER;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;

+    if((H5T_NATIVE_ULLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_ULLONG_ALIGN_g = 1;

+

+   /*

+    *    3        2        1        0

+    * SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM

+    * Implicit bit? yes

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_FLOAT;

+    dt->shared->size = 4;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 32;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.f.sign = 31;

+    dt->shared->u.atomic.u.f.epos = 23;

+    dt->shared->u.atomic.u.f.esize = 8;

+    dt->shared->u.atomic.u.f.ebias = 0x0000007f;

+    dt->shared->u.atomic.u.f.mpos = 0;

+    dt->shared->u.atomic.u.f.msize = 23;

+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;

+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;

+    if((H5T_NATIVE_FLOAT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_FLOAT_ALIGN_g = 1;

+    H5T_NATIVE_FLOAT_COMP_ALIGN_g = 4;

+

+   /*

+    *    7        6        5        4

+    * SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM

+    *    3        2        1        0

+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM

+    * Implicit bit? yes

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_FLOAT;

+    dt->shared->size = 8;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 64;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.f.sign = 63;

+    dt->shared->u.atomic.u.f.epos = 52;

+    dt->shared->u.atomic.u.f.esize = 11;

+    dt->shared->u.atomic.u.f.ebias = 0x000003ff;

+    dt->shared->u.atomic.u.f.mpos = 0;

+    dt->shared->u.atomic.u.f.msize = 52;

+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;

+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;

+    if((H5T_NATIVE_DOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_DOUBLE_ALIGN_g = 1;

+    H5T_NATIVE_DOUBLE_COMP_ALIGN_g = 8;

+

+   /*

+    *   11       10        9        8

+    * ???????? ???????? SEEEEEEE EEEEEEEE

+    *    7        6        5        4

+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM

+    *    3        2        1        0

+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM

+    * Implicit bit? no

+    * Alignment: none

+    */

+    if(NULL == (dt = H5T__alloc()))

+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")

+    dt->shared->state = H5T_STATE_IMMUTABLE;

+    dt->shared->type = H5T_FLOAT;

+    dt->shared->size = 12;

+    dt->shared->u.atomic.order = H5T_ORDER_LE;

+    dt->shared->u.atomic.offset = 0;

+    dt->shared->u.atomic.prec = 80;

+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;

+    dt->shared->u.atomic.u.f.sign = 79;

+    dt->shared->u.atomic.u.f.epos = 64;

+    dt->shared->u.atomic.u.f.esize = 15;

+    dt->shared->u.atomic.u.f.ebias = 0x00003fff;

+    dt->shared->u.atomic.u.f.mpos = 0;

+    dt->shared->u.atomic.u.f.msize = 64;

+    dt->shared->u.atomic.u.f.norm = H5T_NORM_NONE;

+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;

+    if((H5T_NATIVE_LDOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)

+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")

+    H5T_NATIVE_LDOUBLE_ALIGN_g = 1;

+    H5T_NATIVE_LDOUBLE_COMP_ALIGN_g = 4;

+

+    /* Set the native order for this machine */

+    H5T_native_order_g = H5T_ORDER_LE;

+

+    /* Structure alignment for pointers, hvl_t, hobj_ref_t, hdset_reg_ref_t */

+    H5T_POINTER_COMP_ALIGN_g = 4;

+    H5T_HVL_COMP_ALIGN_g = 4;

+    H5T_HOBJREF_COMP_ALIGN_g = 8;

+    H5T_HDSETREGREF_COMP_ALIGN_g = 1;

+

+done:

+    if(ret_value < 0) {

+        if(dt != NULL) {

+            dt->shared = H5FL_FREE(H5T_shared_t, dt->shared);

+            dt = H5FL_FREE(H5T_t, dt);

+        } /* end if */

+    } /* end if */

+

+    FUNC_LEAVE_NOAPI(ret_value);

+} /* end H5TN_init_interface() */

+

+/****************************************/

+/* ALIGNMENT and signal-handling status */

+/****************************************/

+/* Signal() support: yes */

+/* setjmp() support: no */

+/* longjmp() support: yes */

+/* sigsetjmp() support: no */

+/* siglongjmp() support: no */

+/* sigprocmask() support: no */

+

+/******************************/

+/* signal handlers statistics */

+/******************************/

+/* signal_handlers tested: 10 times */

+/* sigbus_handler called: 5 times */

+/* sigsegv_handler called: 5 times */

diff -urN hdf5-1.8.10.orig/src/H5lib_settings.c hdf5-1.8.10/src/H5lib_settings.c
--- hdf5-1.8.10.orig/src/H5lib_settings.c	1970-01-01 10:00:00.000000000 +1000
+++ hdf5-1.8.10/src/H5lib_settings.c	2012-12-05 22:18:25.000000000 +1100
@@ -0,0 +1,104 @@
+/* Generated automatically by H5make_libsettings -- do not edit */

+

+

+

+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

+ * Copyright by The HDF Group.                                               *

+ * Copyright by the Board of Trustees of the University of Illinois.         *

+ * All rights reserved.                                                      *

+ *                                                                           *

+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *

+ * terms governing use, modification, and redistribution, is contained in    *

+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *

+ * of the source code distribution tree; Copyright.html can be found at the  *

+ * root level of an installed copy of the electronic HDF5 document set and   *

+ * is linked from the top-level documents page.  It can also be found at     *

+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *

+ * access to either file, you may request a copy from help@hdfgroup.org.     *

+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

+ *

+ * Created:		Dec  5, 2012

+ *

+ *

+ * Purpose:		This machine-generated source code contains

+ *			information about the library build configuration

+ *

+ * Modifications:

+ *

+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!

+ *	It was generated by code in `H5make_libsettings.c'.

+ *

+ *-------------------------------------------------------------------------

+ */

+

+char H5libhdf5_settings[]=

+	"	    SUMMARY OF THE HDF5 CONFIGURATION\n"

+	"	    =================================\n"

+	"\n"

+	"General Information:\n"

+	"-------------------\n"

+	"		   HDF5 Version: 1.8.10\n"

+	"		  Configured on: Wed Dec  5 21:23:46 EST 2012\n"

+	"		  Configured by: tonyt@tt-mbp-15.local\n"

+	"		 Configure mode: production\n"

+	"		    Host system: i686-pc-mingw32\n"

+	"	      Uname information: Darwin tt-mbp-15.local 12.2.1 Darwin Kernel Version 12.2.1: Thu Oct 18 16:32:48 PDT 2012; root:xnu-2050.20.9~2/RELEASE_X86_64 x86_64\n"

+	"		       Byte sex: little-endian\n"

+	"		      Libraries: \n"

+	"	     Installation point: /Users/tonyt/dev/mxe/usr/i686-pc-mingw32\n"

+	"\n"

+	"Compiling Options:\n"

+	"------------------\n"

+	"               Compilation Mode: production\n"

+	"                     C Compiler: /Users/tonyt/dev/mxe/usr/bin/i686-pc-mingw32-gcc\n"

+	"                         CFLAGS: \n"

+	"                      H5_CFLAGS:  \n"

+	"                      AM_CFLAGS: \n"

+	"                       CPPFLAGS: -DH5_HAVE_WIN32_API\n"

+	"                    H5_CPPFLAGS:   -DNDEBUG -UH5_DEBUG_API\n"

+	"                    AM_CPPFLAGS: \n"

+	"               Shared C Library: no\n"

+	"               Static C Library: yes\n"

+	"  Statically Linked Executables: no\n"

+	"                        LDFLAGS: \n"

+	"                     H5_LDFLAGS: \n"

+	"                     AM_LDFLAGS: \n"

+	" 	 	Extra libraries:  -lz -lm \n"

+	" 		       Archiver: i686-pc-mingw32-ar\n"

+	" 		 	 Ranlib: i686-pc-mingw32-ranlib\n"

+	" 	      Debugged Packages: \n"

+	"		    API Tracing: no\n"

+	"\n"

+	"Languages:\n"

+	"----------\n"

+	"                        Fortran: no\n"

+	"\n"

+	"                            C++: yes\n"

+	"                   C++ Compiler: /Users/tonyt/dev/mxe/usr/bin/i686-pc-mingw32-g++\n"

+	"                      C++ Flags: \n"

+	"                   H5 C++ Flags:  \n"

+	"                   AM C++ Flags: \n"

+	"             Shared C++ Library: no\n"

+	"             Static C++ Library: yes\n"

+	"\n"

+	"Features:\n"

+	"---------\n"

+	"                  Parallel HDF5: no\n"

+	"             High Level library: yes\n"

+	"                   Threadsafety: no\n"

+	"            Default API Mapping: v18\n"

+	" With Deprecated Public Symbols: yes\n"

+	"         I/O filters (external): deflate(zlib)\n"

+	"         I/O filters (internal): shuffle,fletcher32,nbit,scaleoffset\n"

+	"                            MPE: no\n"

+	"                     Direct VFD: no\n"

+	"                        dmalloc: no\n"

+	"Clear file buffers before write: yes\n"

+	"           Using memory checker: no\n"

+	"         Function Stack Tracing: no\n"

+	"                           GPFS: no\n"

+	"      Strict File Format Checks: no\n"

+	"   Optimization Instrumentation: no\n"

+	"       Large File Support (LFS): yes\n"

+;

+

diff -urN hdf5-1.8.10.orig/src/Makefile.in hdf5-1.8.10/src/Makefile.in
--- hdf5-1.8.10.orig/src/Makefile.in	2012-12-05 22:16:19.000000000 +1100
+++ hdf5-1.8.10/src/Makefile.in	2012-12-05 22:17:09.000000000 +1100
@@ -171,7 +171,7 @@
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
-am__v_lt_1 =
+am__v_lt_1 =
 libhdf5_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(libhdf5_la_LDFLAGS) $(LDFLAGS) -o $@
@@ -192,11 +192,11 @@
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
 am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 =
+am__v_GEN_1 =
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
-am__v_at_1 =
+am__v_at_1 =
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/bin/depcomp
 am__depfiles_maybe = depfiles
@@ -210,7 +210,7 @@
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
 am__v_CC_0 = @echo "  CC      " $@;
-am__v_CC_1 =
+am__v_CC_1 =
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
@@ -218,7 +218,7 @@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
 am__v_CCLD_0 = @echo "  CCLD    " $@;
-am__v_CCLD_1 =
+am__v_CCLD_1 =
 SOURCES = $(libhdf5_la_SOURCES) H5detect.c H5make_libsettings.c
 DIST_SOURCES = $(libhdf5_la_SOURCES) H5detect.c H5make_libsettings.c
 am__can_run_installinfo = \
@@ -241,7 +241,7 @@

 # H5_CFLAGS holds flags that should be used when building hdf5,
 # but which should not be exported to h5cc for building other programs.
-# AM_CFLAGS is an automake construct which should be used by Makefiles
+# AM_CFLAGS is an automake construct which should be used by Makefiles
 # instead of CFLAGS, as CFLAGS is reserved solely for the user to define.
 # This applies to FCFLAGS, CXXFLAGS, CPPFLAGS, and LDFLAGS as well.
 AM_CFLAGS = @AM_CFLAGS@ @H5_CFLAGS@
@@ -485,15 +485,15 @@
 LIBH5F_HL = $(top_builddir)/hl/fortran/src/libhdf5hl_fortran.la
 LIBH5CPP_HL = $(top_builddir)/hl/c++/src/libhdf5_hl_cpp.la

-# Note that in svn revision 19400 the '/' after DESTDIR in H5* variables below
-# has been removed. According to the official description of DESTDIR by Gnu at
-# http://www.gnu.org/prep/standards/html_node/DESTDIR.html, DESTDIR is
-# prepended to the normal and complete install path that it precedes for the
-# purpose of installing in a temporary directory which is useful for building
-# rpms and other packages.  The '/' after ${DESTDIR} will be followed by another
-# '/' at the beginning of the normal install path.  When DESTDIR is empty the
-# path then begins with '//', which is incorrect and causes problems at least for
-# Cygwin.
+# Note that in svn revision 19400 the '/' after DESTDIR in H5* variables below
+# has been removed. According to the official description of DESTDIR by Gnu at
+# http://www.gnu.org/prep/standards/html_node/DESTDIR.html, DESTDIR is
+# prepended to the normal and complete install path that it precedes for the
+# purpose of installing in a temporary directory which is useful for building
+# rpms and other packages.  The '/' after ${DESTDIR} will be followed by another
+# '/' at the beginning of the normal install path.  When DESTDIR is empty the
+# path then begins with '//', which is incorrect and causes problems at least for
+# Cygwin.

 # Scripts used to build examples
 # If only shared libraries have been installed, have h5cc build examples with
@@ -616,17 +616,17 @@
 # These will be filled in automatically for the most part (e.g.,
 # lib_LIBRARIES are built for lib target), but EXTRA_LIB, EXTRA_PROG, and
 # EXTRA_TEST variables are supplied to allow the user to force targets to
-# be built at certain times.
+# be built at certain times.
 LIB = $(lib_LIBRARIES) $(lib_LTLIBRARIES) $(noinst_LIBRARIES)                 \
       $(noinst_LTLIBRARIES) $(check_LIBRARIES) $(check_LTLIBRARIES) $(EXTRA_LIB)

 PROGS = $(bin_PROGRAMS) $(bin_SCRIPTS) $(noinst_PROGRAMS) $(noinst_SCRIPTS)   \
         $(EXTRA_PROG)

-chk_TESTS = $(check_PROGRAMS) $(check_SCRIPTS) $(EXTRA_TEST)
+chk_TESTS = $(check_PROGRAMS) $(check_SCRIPTS) $(EXTRA_TEST)
 TEST_EXTENSIONS = .sh
 SH_LOG_COMPILER = $(SHELL)
-AM_SH_LOG_FLAGS =
+AM_SH_LOG_FLAGS =
 TEST_PROG_CHKEXE = $(TEST_PROG:=.chkexe_)
 TEST_PROG_PARA_CHKEXE = $(TEST_PROG_PARA:=.chkexe_)
 TEST_SCRIPT_CHKSH = $(TEST_SCRIPT:=.chkexe_)
@@ -675,7 +675,7 @@
 stamp-h1: $(srcdir)/H5config.h.in $(top_builddir)/config.status
 	@rm -f stamp-h1
 	cd $(top_builddir) && $(SHELL) ./config.status src/H5config.h
-$(srcdir)/H5config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+$(srcdir)/H5config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
 	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
 	rm -f stamp-h1
 	touch $@
@@ -718,7 +718,7 @@
 	  echo rm -f $${locs}; \
 	  rm -f $${locs}; \
 	}
-libhdf5.la: $(libhdf5_la_OBJECTS) $(libhdf5_la_DEPENDENCIES) $(EXTRA_libhdf5_la_DEPENDENCIES)
+libhdf5.la: $(libhdf5_la_OBJECTS) $(libhdf5_la_DEPENDENCIES) $(EXTRA_libhdf5_la_DEPENDENCIES)
 	$(AM_V_CCLD)$(libhdf5_la_LINK) -rpath $(libdir) $(libhdf5_la_OBJECTS) $(libhdf5_la_LIBADD) $(LIBS)

 clean-noinstPROGRAMS:
@@ -729,10 +729,10 @@
 	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
 	echo " rm -f" $$list; \
 	rm -f $$list
-H5detect$(EXEEXT): $(H5detect_OBJECTS) $(H5detect_DEPENDENCIES) $(EXTRA_H5detect_DEPENDENCIES)
+H5detect$(EXEEXT): $(H5detect_OBJECTS) $(H5detect_DEPENDENCIES) $(EXTRA_H5detect_DEPENDENCIES)
 	@rm -f H5detect$(EXEEXT)
 	$(AM_V_CCLD)$(H5detect_LINK) $(H5detect_OBJECTS) $(H5detect_LDADD) $(LIBS)
-H5make_libsettings$(EXEEXT): $(H5make_libsettings_OBJECTS) $(H5make_libsettings_DEPENDENCIES) $(EXTRA_H5make_libsettings_DEPENDENCIES)
+H5make_libsettings$(EXEEXT): $(H5make_libsettings_OBJECTS) $(H5make_libsettings_DEPENDENCIES) $(EXTRA_H5make_libsettings_DEPENDENCIES)
 	@rm -f H5make_libsettings$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(H5make_libsettings_OBJECTS) $(H5make_libsettings_LDADD) $(LIBS)

@@ -1326,24 +1326,12 @@
 # Things should have been all set during H5detect making.
 # Remove the generated .c file if errors occur unless HDF5_Make_Ignore
 # is set to ignore the error.
-H5Tinit.c: H5detect$(EXEEXT)
-	LD_LIBRARY_PATH="$$LD_LIBRARY_PATH`echo $(LDFLAGS) |                  \
-		sed -e 's/-L/:/g' -e 's/ //g'`"                               \
-	$(RUNSERIAL) ./H5detect$(EXEEXT) > $@  ||                               \
-	    (test $$HDF5_Make_Ignore && echo "*** Error ignored") ||          \
-	    ($(RM) $@ ; exit 1)

 # Build configuration header file generation
 # The LD_LIBRARY_PATH setting is a kludge.
 # Things should have been all set during H5make_libsettings making.
 # Remove the generated .c file if errors occur unless HDF5_Make_Ignore
 # is set to ignore the error.
-H5lib_settings.c: H5make_libsettings$(EXEEXT) libhdf5.settings
-	LD_LIBRARY_PATH="$$LD_LIBRARY_PATH`echo $(LDFLAGS) |                  \
-		sed -e 's/-L/:/g' -e 's/ //g'`"                               \
-	$(RUNSERIAL) ./H5make_libsettings$(EXEEXT) > $@  ||                               \
-	    (test $$HDF5_Make_Ignore && echo "*** Error ignored") ||          \
-	    ($(RM) $@ ; exit 1)

 # Error header generation
 #
diff -urN hdf5-1.8.10.orig/src/Makefile.am hdf5-1.8.10/src/Makefile.am
--- hdf5-1.8.10.orig/src/Makefile.am	2012-12-05 22:27:17.000000000 +1100
+++ hdf5-1.8.10/src/Makefile.am	2012-12-05 22:27:33.000000000 +1100
@@ -124,24 +124,12 @@
 # Things should have been all set during H5detect making.
 # Remove the generated .c file if errors occur unless HDF5_Make_Ignore
 # is set to ignore the error.
-H5Tinit.c: H5detect$(EXEEXT)
-	LD_LIBRARY_PATH="$$LD_LIBRARY_PATH`echo $(LDFLAGS) |                  \
-		sed -e 's/-L/:/g' -e 's/ //g'`"                               \
-	$(RUNSERIAL) ./H5detect$(EXEEXT) > $@  ||                               \
-	    (test $$HDF5_Make_Ignore && echo "*** Error ignored") ||          \
-	    ($(RM) $@ ; exit 1)

 # Build configuration header file generation
 # The LD_LIBRARY_PATH setting is a kludge.
 # Things should have been all set during H5make_libsettings making.
 # Remove the generated .c file if errors occur unless HDF5_Make_Ignore
 # is set to ignore the error.
-H5lib_settings.c: H5make_libsettings$(EXEEXT) libhdf5.settings
-	LD_LIBRARY_PATH="$$LD_LIBRARY_PATH`echo $(LDFLAGS) |                  \
-		sed -e 's/-L/:/g' -e 's/ //g'`"                               \
-	$(RUNSERIAL) ./H5make_libsettings$(EXEEXT) > $@  ||                               \
-	    (test $$HDF5_Make_Ignore && echo "*** Error ignored") ||          \
-	    ($(RM) $@ ; exit 1)

 # Error header generation
 #
