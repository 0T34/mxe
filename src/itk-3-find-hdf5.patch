# This file is part of MXE.
# See index.html for further information.

diff -urN InsightToolkit-4.4.0.orig/CMake/FindHDF5.cmake InsightToolkit-4.4.0/CMake/FindHDF5.cmake
--- InsightToolkit-4.4.0.orig/CMake/FindHDF5.cmake	1970-01-01 10:00:00.000000000 +1000
+++ InsightToolkit-4.4.0/CMake/FindHDF5.cmake	2013-07-22 17:19:34.000000000 +1000
@@ -0,0 +1,385 @@
+# - Find HDF5, a library for reading and writing self describing array data.
+#
+# This module invokes the HDF5 wrapper compiler that should be installed
+# alongside HDF5.  Depending upon the HDF5 Configuration, the wrapper compiler
+# is called either h5cc or h5pcc.  If this succeeds, the module will then call
+# the compiler with the -show argument to see what flags are used when compiling
+# an HDF5 client application.
+#
+# The module will optionally accept the COMPONENTS argument.  If no COMPONENTS
+# are specified, then the find module will default to finding only the HDF5 C
+# library.  If one or more COMPONENTS are specified, the module will attempt to
+# find the language bindings for the specified components.  The only valid
+# components are C, CXX, Fortran, HL, and Fortran_HL.  If the COMPONENTS
+# argument is not given, the module will attempt to find only the C bindings.
+#
+# On UNIX systems, this module will read the variable HDF5_USE_STATIC_LIBRARIES
+# to determine whether or not to prefer a static link to a dynamic link for HDF5
+# and all of it's dependencies.  To use this feature, make sure that the
+# HDF5_USE_STATIC_LIBRARIES variable is set before the call to find_package.
+#
+# To provide the module with a hint about where to find your HDF5 installation,
+# you can set the environment variable HDF5_ROOT.  The Find module will then
+# look in this path when searching for HDF5 executables, paths, and libraries.
+#
+# In addition to finding the includes and libraries required to compile an HDF5
+# client application, this module also makes an effort to find tools that come
+# with the HDF5 distribution that may be useful for regression testing.
+#
+# This module will define the following variables:
+#  HDF5_INCLUDE_DIRS - Location of the hdf5 includes
+#  HDF5_INCLUDE_DIR - Location of the hdf5 includes (deprecated)
+#  HDF5_DEFINITIONS - Required compiler definitions for HDF5
+#  HDF5_C_LIBRARIES - Required libraries for the HDF5 C bindings.
+#  HDF5_CXX_LIBRARIES - Required libraries for the HDF5 C++ bindings
+#  HDF5_Fortran_LIBRARIES - Required libraries for the HDF5 Fortran bindings
+#  HDF5_HL_LIBRARIES - Required libraries for the HDF5 high level API
+#  HDF5_Fortran_HL_LIBRARIES - Required libraries for the high level Fortran
+#                              bindings.
+#  HDF5_LIBRARIES - Required libraries for all requested bindings
+#  HDF5_FOUND - true if HDF5 was found on the system
+#  HDF5_LIBRARY_DIRS - the full set of library directories
+#  HDF5_IS_PARALLEL - Whether or not HDF5 was found with parallel IO support
+#  HDF5_C_COMPILER_EXECUTABLE - the path to the HDF5 C wrapper compiler
+#  HDF5_CXX_COMPILER_EXECUTABLE - the path to the HDF5 C++ wrapper compiler
+#  HDF5_Fortran_COMPILER_EXECUTABLE - the path to the HDF5 Fortran wrapper compiler
+#  HDF5_DIFF_EXECUTABLE - the path to the HDF5 dataset comparison tool
+
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distribute this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+# This module is maintained by Will Dicharry <wdicharry@stellarscience.com>.
+
+include(SelectLibraryConfigurations)
+include(${CMAKE_CURRENT_LIST_DIR}/FindPackageHandleStandardArgs.cmake)
+
+# List of the valid HDF5 components
+set( HDF5_VALID_COMPONENTS
+    C
+    CXX
+    Fortran
+    HL
+    Fortran_HL
+)
+
+# Validate the list of find components.
+if( NOT HDF5_FIND_COMPONENTS )
+    set( HDF5_LANGUAGE_BINDINGS "C" )
+else()
+    # add the extra specified components, ensuring that they are valid.
+    foreach( component ${HDF5_FIND_COMPONENTS} )
+        list( FIND HDF5_VALID_COMPONENTS ${component} component_location )
+        if( ${component_location} EQUAL -1 )
+            message( FATAL_ERROR
+                "\"${component}\" is not a valid HDF5 component." )
+        else()
+            list( APPEND HDF5_LANGUAGE_BINDINGS ${component} )
+        endif()
+    endforeach()
+endif()
+
+# try to find the HDF5 wrapper compilers
+find_program( HDF5_C_COMPILER_EXECUTABLE
+    NAMES h5cc h5pcc
+    HINTS ENV HDF5_ROOT
+    PATH_SUFFIXES bin Bin
+    DOC "HDF5 Wrapper compiler.  Used only to detect HDF5 compile flags." )
+mark_as_advanced( HDF5_C_COMPILER_EXECUTABLE )
+
+find_program( HDF5_CXX_COMPILER_EXECUTABLE
+    NAMES h5c++ h5pc++
+    HINTS ENV HDF5_ROOT
+    PATH_SUFFIXES bin Bin
+    DOC "HDF5 C++ Wrapper compiler.  Used only to detect HDF5 compile flags." )
+mark_as_advanced( HDF5_CXX_COMPILER_EXECUTABLE )
+
+find_program( HDF5_Fortran_COMPILER_EXECUTABLE
+    NAMES h5fc h5pfc
+    HINTS ENV HDF5_ROOT
+    PATH_SUFFIXES bin Bin
+    DOC "HDF5 Fortran Wrapper compiler.  Used only to detect HDF5 compile flags." )
+mark_as_advanced( HDF5_Fortran_COMPILER_EXECUTABLE )
+
+find_program( HDF5_DIFF_EXECUTABLE
+    NAMES h5diff
+    HINTS ENV HDF5_ROOT
+    PATH_SUFFIXES bin Bin
+    DOC "HDF5 file differencing tool." )
+mark_as_advanced( HDF5_DIFF_EXECUTABLE )
+
+# Invoke the HDF5 wrapper compiler.  The compiler return value is stored to the
+# return_value argument, the text output is stored to the output variable.
+macro( _HDF5_invoke_compiler language output return_value )
+    if( HDF5_${language}_COMPILER_EXECUTABLE )
+        exec_program( ${HDF5_${language}_COMPILER_EXECUTABLE}
+            ARGS -show
+            OUTPUT_VARIABLE ${output}
+            RETURN_VALUE ${return_value}
+        )
+        if( ${${return_value}} EQUAL 0 )
+            # do nothing
+        else()
+            message( STATUS
+              "Unable to determine HDF5 ${language} flags from HDF5 wrapper." )
+        endif()
+    endif()
+endmacro()
+
+# Parse a compile line for definitions, includes, library paths, and libraries.
+macro( _HDF5_parse_compile_line
+    compile_line_var
+    include_paths
+    definitions
+    library_paths
+    libraries )
+
+    # Match the include paths
+    string( REGEX MATCHALL "-I([^\" ]+)" include_path_flags
+        "${${compile_line_var}}"
+    )
+    foreach( IPATH ${include_path_flags} )
+        string( REGEX REPLACE "^-I" "" IPATH ${IPATH} )
+        string( REGEX REPLACE "//" "/" IPATH ${IPATH} )
+        list( APPEND ${include_paths} ${IPATH} )
+    endforeach()
+
+    # Match the definitions
+    string( REGEX MATCHALL "-D[^ ]*" definition_flags "${${compile_line_var}}" )
+    foreach( DEF ${definition_flags} )
+        list( APPEND ${definitions} ${DEF} )
+    endforeach()
+
+    # Match the library paths
+    string( REGEX MATCHALL "-L([^\" ]+|\"[^\"]+\")" library_path_flags
+        "${${compile_line_var}}"
+    )
+
+    foreach( LPATH ${library_path_flags} )
+        string( REGEX REPLACE "^-L" "" LPATH ${LPATH} )
+        string( REGEX REPLACE "//" "/" LPATH ${LPATH} )
+        list( APPEND ${library_paths} ${LPATH} )
+    endforeach()
+
+    # now search for the library names specified in the compile line (match -l...)
+    # match only -l's preceded by a space or comma
+    # this is to exclude directory names like xxx-linux/
+    string( REGEX MATCHALL "[, ]-l([^\", ]+)" library_name_flags
+        "${${compile_line_var}}" )
+    # strip the -l from all of the library flags and add to the search list
+    foreach( LIB ${library_name_flags} )
+        string( REGEX REPLACE "^[, ]-l" "" LIB ${LIB} )
+        list( APPEND ${libraries} ${LIB} )
+    endforeach()
+endmacro()
+
+# Try to find HDF5 using an installed hdf5-config.cmake
+if( NOT HDF5_FOUND )
+    find_package( HDF5 QUIET NO_MODULE )
+    if( HDF5_FOUND )
+        set( HDF5_INCLUDE_DIRS ${HDF5_INCLUDE_DIR} )
+        set( HDF5_LIBRARIES )
+        set( HDF5_C_TARGET hdf5 )
+        set( HDF5_CXX_TARGET hdf5_cpp )
+        set( HDF5_HL_TARGET hdf5_hl )
+        set( HDF5_Fortran_TARGET hdf5_fortran )
+        set( HDF5_Fortran_HL_TARGET hdf5_hl_fortran )
+        foreach( _component ${HDF5_LANGUAGE_BINDINGS} )
+            list( FIND HDF5_VALID_COMPONENTS ${_component} _component_location )
+            get_target_property( _comp_location ${HDF5_${_component}_TARGET} LOCATION )
+            if( _comp_location )
+                set( HDF5_${_component}_LIBRARY ${_comp_location} CACHE PATH
+                    "HDF5 ${_component} library" )
+                mark_as_advanced( HDF5_${_component}_LIBRARY )
+                list( APPEND HDF5_LIBRARIES ${HDF5_${_component}_LIBRARY} )
+            endif()
+        endforeach()
+    endif()
+endif()
+
+if( NOT HDF5_FOUND )
+    _HDF5_invoke_compiler( C HDF5_C_COMPILE_LINE HDF5_C_RETURN_VALUE )
+    _HDF5_invoke_compiler( CXX HDF5_CXX_COMPILE_LINE HDF5_CXX_RETURN_VALUE )
+    _HDF5_invoke_compiler( Fortran HDF5_Fortran_COMPILE_LINE HDF5_Fortran_RETURN_VALUE )
+
+    # seed the initial lists of libraries to find with items we know we need
+    set( HDF5_C_LIBRARY_NAMES_INIT hdf5 )
+    set( HDF5_HL_LIBRARY_NAMES_INIT hdf5_hl ${HDF5_C_LIBRARY_NAMES_INIT} )
+    set( HDF5_CXX_LIBRARY_NAMES_INIT hdf5_cpp ${HDF5_C_LIBRARY_NAMES_INIT} )
+    set( HDF5_Fortran_LIBRARY_NAMES_INIT hdf5_fortran
+        ${HDF5_C_LIBRARY_NAMES_INIT} )
+    set( HDF5_Fortran_HL_LIBRARY_NAMES_INIT hdf5hl_fortran
+        ${HDF5_Fortran_LIBRARY_NAMES_INIT} )
+
+    foreach( LANGUAGE ${HDF5_LANGUAGE_BINDINGS} )
+        if( HDF5_${LANGUAGE}_COMPILE_LINE )
+            _HDF5_parse_compile_line( HDF5_${LANGUAGE}_COMPILE_LINE
+                HDF5_${LANGUAGE}_INCLUDE_FLAGS
+                HDF5_${LANGUAGE}_DEFINITIONS
+                HDF5_${LANGUAGE}_LIBRARY_DIRS
+                HDF5_${LANGUAGE}_LIBRARY_NAMES
+            )
+
+            # take a guess that the includes may be in the 'include' sibling
+            # directory of a library directory.
+            foreach( dir ${HDF5_${LANGUAGE}_LIBRARY_DIRS} )
+                list( APPEND HDF5_${LANGUAGE}_INCLUDE_FLAGS ${dir}/../include )
+            endforeach()
+        endif()
+
+        # set the definitions for the language bindings.
+        list( APPEND HDF5_DEFINITIONS ${HDF5_${LANGUAGE}_DEFINITIONS} )
+
+        # find the HDF5 include directories
+        if(${LANGUAGE} MATCHES "Fortran.*")
+            set(HDF5_INCLUDE_FILENAME hdf5.mod)
+        else()
+            set(HDF5_INCLUDE_FILENAME hdf5.h)
+        endif()
+
+        find_path( HDF5_${LANGUAGE}_INCLUDE_DIR ${HDF5_INCLUDE_FILENAME}
+            HINTS
+                ${HDF5_${LANGUAGE}_INCLUDE_FLAGS}
+                ENV
+                    HDF5_ROOT
+            PATHS
+                $ENV{HOME}/.local/include
+            PATH_SUFFIXES
+                include
+                Include
+        )
+        mark_as_advanced( HDF5_${LANGUAGE}_INCLUDE_DIR )
+        list( APPEND HDF5_INCLUDE_DIRS ${HDF5_${LANGUAGE}_INCLUDE_DIR} )
+
+        set( HDF5_${LANGUAGE}_LIBRARY_NAMES
+            ${HDF5_${LANGUAGE}_LIBRARY_NAMES_INIT}
+            ${HDF5_${LANGUAGE}_LIBRARY_NAMES} )
+
+        # find the HDF5 libraries
+        foreach( LIB ${HDF5_${LANGUAGE}_LIBRARY_NAMES} )
+            if( UNIX AND HDF5_USE_STATIC_LIBRARIES )
+                # According to bug 1643 on the CMake bug tracker, this is the
+                # preferred method for searching for a static library.
+                # See http://www.cmake.org/Bug/view.php?id=1643.  We search
+                # first for the full static library name, but fall back to a
+                # generic search on the name if the static search fails.
+                set( THIS_LIBRARY_SEARCH_DEBUG lib${LIB}d.a ${LIB}d )
+                set( THIS_LIBRARY_SEARCH_RELEASE lib${LIB}.a ${LIB} )
+            else()
+                set( THIS_LIBRARY_SEARCH_DEBUG ${LIB}d )
+                set( THIS_LIBRARY_SEARCH_RELEASE ${LIB} )
+            endif()
+            find_library( HDF5_${LIB}_LIBRARY_DEBUG
+                NAMES ${THIS_LIBRARY_SEARCH_DEBUG}
+                HINTS ${HDF5_${LANGUAGE}_LIBRARY_DIRS}
+                ENV HDF5_ROOT
+                PATH_SUFFIXES lib Lib )
+            find_library( HDF5_${LIB}_LIBRARY_RELEASE
+                NAMES ${THIS_LIBRARY_SEARCH_RELEASE}
+                HINTS ${HDF5_${LANGUAGE}_LIBRARY_DIRS}
+                ENV HDF5_ROOT
+                PATH_SUFFIXES lib Lib )
+            select_library_configurations( HDF5_${LIB} )
+            # even though we adjusted the individual library names in
+            # select_library_configurations, we still need to distinguish
+            # between debug and release variants because HDF5_LIBRARIES will
+            # need to specify different lists for debug and optimized builds.
+            # We can't just use the HDF5_${LIB}_LIBRARY variable (which was set
+            # up by the selection macro above) because it may specify debug and
+            # optimized variants for a particular library, but a list of
+            # libraries is allowed to specify debug and optimized only once.
+            list( APPEND HDF5_${LANGUAGE}_LIBRARIES_DEBUG
+                ${HDF5_${LIB}_LIBRARY_DEBUG} )
+            list( APPEND HDF5_${LANGUAGE}_LIBRARIES_RELEASE
+                ${HDF5_${LIB}_LIBRARY_RELEASE} )
+        endforeach()
+        list( APPEND HDF5_LIBRARY_DIRS ${HDF5_${LANGUAGE}_LIBRARY_DIRS} )
+
+        # Append the libraries for this language binding to the list of all
+        # required libraries.
+        list( APPEND HDF5_LIBRARIES_DEBUG
+            ${HDF5_${LANGUAGE}_LIBRARIES_DEBUG} )
+        list( APPEND HDF5_LIBRARIES_RELEASE
+            ${HDF5_${LANGUAGE}_LIBRARIES_RELEASE} )
+    endforeach()
+
+    # We may have picked up some duplicates in various lists during the above
+    # process for the language bindings (both the C and C++ bindings depend on
+    # libz for example).  Remove the duplicates. It appears that the default
+    # CMake behavior is to remove duplicates from the end of a list. However,
+    # for link lines, this is incorrect since unresolved symbols are searched
+    # for down the link line. Therefore, we reverse the list, remove the
+    # duplicates, and then reverse it again to get the duplicates removed from
+    # the beginning.
+    macro( _remove_duplicates_from_beginning _list_name )
+        list( REVERSE ${_list_name} )
+        list( REMOVE_DUPLICATES ${_list_name} )
+        list( REVERSE ${_list_name} )
+    endmacro()
+
+    if( HDF5_INCLUDE_DIRS )
+        _remove_duplicates_from_beginning( HDF5_INCLUDE_DIRS )
+    endif()
+    if( HDF5_LIBRARIES_DEBUG )
+        _remove_duplicates_from_beginning( HDF5_LIBRARIES_DEBUG )
+    endif()
+    if( HDF5_LIBRARIES_RELEASE )
+        _remove_duplicates_from_beginning( HDF5_LIBRARIES_RELEASE )
+    endif()
+    if( HDF5_LIBRARY_DIRS )
+        _remove_duplicates_from_beginning( HDF5_LIBRARY_DIRS )
+    endif()
+
+    # Construct the complete list of HDF5 libraries with debug and optimized
+    # variants when the generator supports them.
+    if( CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE )
+        set( HDF5_LIBRARIES )
+        foreach( _lib ${HDF5_LIBRARIES_DEBUG} )
+            list( APPEND HDF5_LIBRARIES debug ${_lib} )
+        endforeach()
+        foreach( _lib ${HDF5_LIBRARIES_RELEASE} )
+            list( APPEND HDF5_LIBRARIES optimized ${_lib} )
+        endforeach()
+    else()
+        set( HDF5_LIBRARIES ${HDF5_LIBRARIES_RELEASE} )
+    endif()
+
+    # If the HDF5 include directory was found, open H5pubconf.h to determine if
+    # HDF5 was compiled with parallel IO support
+    set( HDF5_IS_PARALLEL FALSE )
+    foreach( _dir IN LISTS HDF5_INCLUDE_DIRS )
+        if( EXISTS "${_dir}/H5pubconf.h" )
+            file( STRINGS "${_dir}/H5pubconf.h"
+                HDF5_HAVE_PARALLEL_DEFINE
+                REGEX "HAVE_PARALLEL 1" )
+            if( HDF5_HAVE_PARALLEL_DEFINE )
+                set( HDF5_IS_PARALLEL TRUE )
+            endif()
+        endif()
+    endforeach()
+    set( HDF5_IS_PARALLEL ${HDF5_IS_PARALLEL} CACHE BOOL
+        "HDF5 library compiled with parallel IO support" )
+    mark_as_advanced( HDF5_IS_PARALLEL )
+
+    # For backwards compatibility we set HDF5_INCLUDE_DIR to the value of
+    # HDF5_INCLUDE_DIRS
+    if( HDF5_INCLUDE_DIRS )
+        set( HDF5_INCLUDE_DIR "${HDF5_INCLUDE_DIRS}" )
+    endif()
+
+endif()
+
+find_package_handle_standard_args( HDF5 DEFAULT_MSG
+    HDF5_LIBRARIES
+    HDF5_INCLUDE_DIRS
+)
+
diff -urN InsightToolkit-4.4.0.orig/CMake/FindPackageHandleStandardArgs.cmake InsightToolkit-4.4.0/CMake/FindPackageHandleStandardArgs.cmake
--- InsightToolkit-4.4.0.orig/CMake/FindPackageHandleStandardArgs.cmake	1970-01-01 10:00:00.000000000 +1000
+++ InsightToolkit-4.4.0/CMake/FindPackageHandleStandardArgs.cmake	2013-07-22 17:25:52.000000000 +1000
@@ -0,0 +1,299 @@
+# FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> ... )
+#
+# This function is intended to be used in FindXXX.cmake modules files.
+# It handles the REQUIRED, QUIET and version-related arguments to find_package().
+# It also sets the <UPPERCASED_NAME>_FOUND variable.
+# The package is considered found if all variables <var1>... listed contain
+# valid results, e.g. valid filepaths.
+#
+# There are two modes of this function. The first argument in both modes is
+# the name of the Find-module where it is called (in original casing).
+#
+# The first simple mode looks like this:
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> (DEFAULT_MSG|"Custom failure message") <var1>...<varN> )
+# If the variables <var1> to <varN> are all valid, then <UPPERCASED_NAME>_FOUND
+# will be set to TRUE.
+# If DEFAULT_MSG is given as second argument, then the function will generate
+# itself useful success and error messages. You can also supply a custom error message
+# for the failure case. This is not recommended.
+#
+# The second mode is more powerful and also supports version checking:
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME [REQUIRED_VARS <var1>...<varN>]
+#                                           [VERSION_VAR   <versionvar>]
+#                                           [HANDLE_COMPONENTS]
+#                                           [CONFIG_MODE]
+#                                           [FAIL_MESSAGE "Custom failure message"] )
+#
+# As above, if <var1> through <varN> are all valid, <UPPERCASED_NAME>_FOUND
+# will be set to TRUE.
+# After REQUIRED_VARS the variables which are required for this package are listed.
+# Following VERSION_VAR the name of the variable can be specified which holds
+# the version of the package which has been found. If this is done, this version
+# will be checked against the (potentially) specified required version used
+# in the find_package() call. The EXACT keyword is also handled. The default
+# messages include information about the required version and the version
+# which has been actually found, both if the version is ok or not.
+# If the package supports components, use the HANDLE_COMPONENTS option to enable
+# handling them. In this case, find_package_handle_standard_args() will report
+# which components have been found and which are missing, and the <NAME>_FOUND
+# variable will be set to FALSE if any of the required components (i.e. not the
+# ones listed after OPTIONAL_COMPONENTS) are missing.
+# Use the option CONFIG_MODE if your FindXXX.cmake module is a wrapper for
+# a find_package(... NO_MODULE) call.  In this case VERSION_VAR will be set
+# to <NAME>_VERSION and the macro will automatically check whether the
+# Config module was found.
+# Via FAIL_MESSAGE a custom failure message can be specified, if this is not
+# used, the default message will be displayed.
+#
+# Example for mode 1:
+#
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(LibXml2  DEFAULT_MSG  LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR)
+#
+# LibXml2 is considered to be found, if both LIBXML2_LIBRARY and
+# LIBXML2_INCLUDE_DIR are valid. Then also LIBXML2_FOUND is set to TRUE.
+# If it is not found and REQUIRED was used, it fails with FATAL_ERROR,
+# independent whether QUIET was used or not.
+# If it is found, success will be reported, including the content of <var1>.
+# On repeated Cmake runs, the same message won't be printed again.
+#
+# Example for mode 2:
+#
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(BISON  REQUIRED_VARS BISON_EXECUTABLE
+#                                             VERSION_VAR BISON_VERSION)
+# In this case, BISON is considered to be found if the variable(s) listed
+# after REQUIRED_VAR are all valid, i.e. BISON_EXECUTABLE in this case.
+# Also the version of BISON will be checked by using the version contained
+# in BISON_VERSION.
+# Since no FAIL_MESSAGE is given, the default messages will be printed.
+#
+# Another example for mode 2:
+#
+#    find_package(Automoc4 QUIET NO_MODULE HINTS /opt/automoc4)
+#    FIND_PACKAGE_HANDLE_STANDARD_ARGS(Automoc4  CONFIG_MODE)
+# In this case, FindAutmoc4.cmake wraps a call to find_package(Automoc4 NO_MODULE)
+# and adds an additional search directory for automoc4.
+# The following FIND_PACKAGE_HANDLE_STANDARD_ARGS() call produces a proper
+# success/error message.
+
+#=============================================================================
+# Copyright 2007-2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distribute this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+include(FindPackageMessage)
+include(CMakeParseArguments)
+
+# internal helper macro
+macro(_FPHSA_FAILURE_MESSAGE _msg)
+  if (${_NAME}_FIND_REQUIRED)
+    message(FATAL_ERROR "${_msg}")
+  else ()
+    if (NOT ${_NAME}_FIND_QUIETLY)
+      message(STATUS "${_msg}")
+    endif ()
+  endif ()
+endmacro()
+
+
+# internal helper macro to generate the failure message when used in CONFIG_MODE:
+macro(_FPHSA_HANDLE_FAILURE_CONFIG_MODE)
+  # <name>_CONFIG is set, but FOUND is false, this means that some other of the REQUIRED_VARS was not found:
+  if(${_NAME}_CONFIG)
+    _FPHSA_FAILURE_MESSAGE("${FPHSA_FAIL_MESSAGE}: missing: ${MISSING_VARS} (found ${${_NAME}_CONFIG} ${VERSION_MSG})")
+  else()
+    # If _CONSIDERED_CONFIGS is set, the config-file has been found, but no suitable version.
+    # List them all in the error message:
+    if(${_NAME}_CONSIDERED_CONFIGS)
+      set(configsText "")
+      list(LENGTH ${_NAME}_CONSIDERED_CONFIGS configsCount)
+      math(EXPR configsCount "${configsCount} - 1")
+      foreach(currentConfigIndex RANGE ${configsCount})
+        list(GET ${_NAME}_CONSIDERED_CONFIGS ${currentConfigIndex} filename)
+        list(GET ${_NAME}_CONSIDERED_VERSIONS ${currentConfigIndex} version)
+        set(configsText "${configsText}    ${filename} (version ${version})\n")
+      endforeach()
+      if (${_NAME}_NOT_FOUND_MESSAGE)
+        set(configsText "${configsText}    Reason given by package: ${${_NAME}_NOT_FOUND_MESSAGE}\n")
+      endif()
+      _FPHSA_FAILURE_MESSAGE("${FPHSA_FAIL_MESSAGE} ${VERSION_MSG}, checked the following files:\n${configsText}")
+
+    else()
+      # Simple case: No Config-file was found at all:
+      _FPHSA_FAILURE_MESSAGE("${FPHSA_FAIL_MESSAGE}: found neither ${_NAME}Config.cmake nor ${_NAME_LOWER}-config.cmake ${VERSION_MSG}")
+    endif()
+  endif()
+endmacro()
+
+
+function(FIND_PACKAGE_HANDLE_STANDARD_ARGS _NAME _FIRST_ARG)
+
+# set up the arguments for CMAKE_PARSE_ARGUMENTS and check whether we are in
+# new extended or in the "old" mode:
+  set(options CONFIG_MODE HANDLE_COMPONENTS)
+  set(oneValueArgs FAIL_MESSAGE VERSION_VAR)
+  set(multiValueArgs REQUIRED_VARS)
+  set(_KEYWORDS_FOR_EXTENDED_MODE  ${options} ${oneValueArgs} ${multiValueArgs} )
+  list(FIND _KEYWORDS_FOR_EXTENDED_MODE "${_FIRST_ARG}" INDEX)
+
+  if(${INDEX} EQUAL -1)
+    set(FPHSA_FAIL_MESSAGE ${_FIRST_ARG})
+    set(FPHSA_REQUIRED_VARS ${ARGN})
+    set(FPHSA_VERSION_VAR)
+  else()
+
+    CMAKE_PARSE_ARGUMENTS(FPHSA "${options}" "${oneValueArgs}" "${multiValueArgs}"  ${_FIRST_ARG} ${ARGN})
+
+    if(FPHSA_UNPARSED_ARGUMENTS)
+      message(FATAL_ERROR "Unknown keywords given to FIND_PACKAGE_HANDLE_STANDARD_ARGS(): \"${FPHSA_UNPARSED_ARGUMENTS}\"")
+    endif()
+
+    if(NOT FPHSA_FAIL_MESSAGE)
+      set(FPHSA_FAIL_MESSAGE  "DEFAULT_MSG")
+    endif()
+  endif()
+
+# now that we collected all arguments, process them
+
+  if("${FPHSA_FAIL_MESSAGE}" STREQUAL "DEFAULT_MSG")
+    set(FPHSA_FAIL_MESSAGE "Could NOT find ${_NAME}")
+  endif()
+
+  # In config-mode, we rely on the variable <package>_CONFIG, which is set by find_package()
+  # when it successfully found the config-file, including version checking:
+  if(FPHSA_CONFIG_MODE)
+    list(INSERT FPHSA_REQUIRED_VARS 0 ${_NAME}_CONFIG)
+    list(REMOVE_DUPLICATES FPHSA_REQUIRED_VARS)
+    set(FPHSA_VERSION_VAR ${_NAME}_VERSION)
+  endif()
+
+  if(NOT FPHSA_REQUIRED_VARS)
+    message(FATAL_ERROR "No REQUIRED_VARS specified for FIND_PACKAGE_HANDLE_STANDARD_ARGS()")
+  endif()
+
+  list(GET FPHSA_REQUIRED_VARS 0 _FIRST_REQUIRED_VAR)
+
+  string(TOUPPER ${_NAME} _NAME_UPPER)
+  string(TOLOWER ${_NAME} _NAME_LOWER)
+
+  # collect all variables which were not found, so they can be printed, so the
+  # user knows better what went wrong (#6375)
+  set(MISSING_VARS "")
+  set(DETAILS "")
+  set(${_NAME_UPPER}_FOUND TRUE)
+  # check if all passed variables are valid
+  foreach(_CURRENT_VAR ${FPHSA_REQUIRED_VARS})
+    if(NOT ${_CURRENT_VAR})
+      set(${_NAME_UPPER}_FOUND FALSE)
+      set(MISSING_VARS "${MISSING_VARS} ${_CURRENT_VAR}")
+    else()
+      set(DETAILS "${DETAILS}[${${_CURRENT_VAR}}]")
+    endif()
+  endforeach()
+
+  # component handling
+  unset(FOUND_COMPONENTS_MSG)
+  unset(MISSING_COMPONENTS_MSG)
+
+  if(FPHSA_HANDLE_COMPONENTS)
+    foreach(comp ${${_NAME}_FIND_COMPONENTS})
+      if(${_NAME}_${comp}_FOUND)
+
+        if(NOT DEFINED FOUND_COMPONENTS_MSG)
+          set(FOUND_COMPONENTS_MSG "found components: ")
+        endif()
+        set(FOUND_COMPONENTS_MSG "${FOUND_COMPONENTS_MSG} ${comp}")
+
+      else()
+
+        if(NOT DEFINED MISSING_COMPONENTS_MSG)
+          set(MISSING_COMPONENTS_MSG "missing components: ")
+        endif()
+        set(MISSING_COMPONENTS_MSG "${MISSING_COMPONENTS_MSG} ${comp}")
+
+        if(${_NAME}_FIND_REQUIRED_${comp})
+          set(${_NAME_UPPER}_FOUND FALSE)
+          set(MISSING_VARS "${MISSING_VARS} ${comp}")
+        endif()
+
+      endif()
+    endforeach()
+    set(COMPONENT_MSG "${FOUND_COMPONENTS_MSG} ${MISSING_COMPONENTS_MSG}")
+    set(DETAILS "${DETAILS}[c${COMPONENT_MSG}]")
+  endif()
+
+  # version handling:
+  set(VERSION_MSG "")
+  set(VERSION_OK TRUE)
+  set(VERSION ${${FPHSA_VERSION_VAR}} )
+  if (${_NAME}_FIND_VERSION)
+
+    if(VERSION)
+
+      if(${_NAME}_FIND_VERSION_EXACT)       # exact version required
+        if (NOT "${${_NAME}_FIND_VERSION}" VERSION_EQUAL "${VERSION}")
+          set(VERSION_MSG "Found unsuitable version \"${VERSION}\", but required is exact version \"${${_NAME}_FIND_VERSION}\"")
+          set(VERSION_OK FALSE)
+        else ()
+          set(VERSION_MSG "(found suitable exact version \"${VERSION}\")")
+        endif ()
+
+      else()     # minimum version specified:
+        if ("${${_NAME}_FIND_VERSION}" VERSION_GREATER "${VERSION}")
+          set(VERSION_MSG "Found unsuitable version \"${VERSION}\", but required is at least \"${${_NAME}_FIND_VERSION}\"")
+          set(VERSION_OK FALSE)
+        else ()
+          set(VERSION_MSG "(found suitable version \"${VERSION}\", minimum required is \"${${_NAME}_FIND_VERSION}\")")
+        endif ()
+      endif()
+
+    else()
+
+      # if the package was not found, but a version was given, add that to the output:
+      if(${_NAME}_FIND_VERSION_EXACT)
+         set(VERSION_MSG "(Required is exact version \"${${_NAME}_FIND_VERSION}\")")
+      else()
+         set(VERSION_MSG "(Required is at least version \"${${_NAME}_FIND_VERSION}\")")
+      endif()
+
+    endif()
+  else ()
+    if(VERSION)
+      set(VERSION_MSG "(found version \"${VERSION}\")")
+    endif()
+  endif ()
+
+  if(VERSION_OK)
+    set(DETAILS "${DETAILS}[v${VERSION}(${${_NAME}_FIND_VERSION})]")
+  else()
+    set(${_NAME_UPPER}_FOUND FALSE)
+  endif()
+
+
+  # print the result:
+  if (${_NAME_UPPER}_FOUND)
+    FIND_PACKAGE_MESSAGE(${_NAME} "Found ${_NAME}: ${${_FIRST_REQUIRED_VAR}} ${VERSION_MSG} ${COMPONENT_MSG}" "${DETAILS}")
+  else ()
+
+    if(FPHSA_CONFIG_MODE)
+      _FPHSA_HANDLE_FAILURE_CONFIG_MODE()
+    else()
+      if(NOT VERSION_OK)
+        _FPHSA_FAILURE_MESSAGE("${FPHSA_FAIL_MESSAGE}: ${VERSION_MSG} (found ${${_FIRST_REQUIRED_VAR}})")
+      else()
+        _FPHSA_FAILURE_MESSAGE("${FPHSA_FAIL_MESSAGE} (missing: ${MISSING_VARS}) ${VERSION_MSG}")
+      endif()
+    endif()
+
+  endif ()
+
+  set(${_NAME_UPPER}_FOUND ${${_NAME_UPPER}_FOUND} PARENT_SCOPE)
+
+endfunction()
